#!/usr/bin/env python
# encoding: utf-8
#
# Created by Callum Stott 2011

import sys
import os 
import time
import signal
import socket
import threading
import Growl

class Listener(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
		self.keeprunning = True
		
	def run(self):
		hole = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		hole.bind(('', 65530))
		hole.listen(1)
		hole.settimeout(0.1)
		while self.keeprunning:
			try:
				stream, address = hole.accept()
			except socket.timeout:
				continue
			if stream.recv(100) == "kill":
				stream.close()
				hole.close()
				killthis()
			elif stream.recv(100) == "info":
				#send info back
				pass
		hole.close()
				
	def kill(self):
		self.keeprunning = False
		
class Timer:
	def __init__(self, time):
		self.time = time
		
	def run(self):
		time.sleep(self.time)

class Growler:
	def __init__(self):
		self.reggrowl()
		
	def notify(self):
		self.growl.notify( "Leaving time", "Time to leave!", "Go go go!", None, True, None)
			
	def reggrowl(self):
		self.growl = Growl.GrowlNotifier( "Leave", ["Leaving time"] )
		self.growl.register()
		
def daemonize():
	try:
		pid = os.fork()	
	except OSError:
		pass
	if pid == 0:
		os.setsid()
		try:
			pid = os.fork()
		except OSError:
			pass		
		if pid != 0:
			os._exit(0)		
	else:
		os._exit(0)
		
def kill():
	kill = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	try:
		kill.connect(('localhost', 65530))
		kill.send("kill")
		kill.close()
	except socket.error:
		pass
			
def killthis():
	os._exit(0)

def alreadyleaving():
	search = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	try:
		search.connect(('localhost', 65530))
		print "How can you leave twice? Would that be staying? Hmmmm...."
		sys.exit(0)
	except socket.error:
		pass
		
def details():
	search = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	try:
		search.connect(('localhost', 65530))
	except socket.error:
		print "What do you mean? You're not going anywhere..."

def startlistener():
	listener = Listener()
	listener.start()
	
	return listener
			
def set(secs):
	daemonize()
	growl = Growler()
	timer = Timer(secs)
	listener = startlistener()
	timer.run()
	growl.notify()
	listener.kill()
	
def getsecsfrommins(input):
	return int(input) * 60
		
def getsecsuntil(input):
	current = time.localtime()
	target = time.strptime(input, "%H:%M")
	hour = target.tm_hour
	
	if target.tm_hour < current.tm_hour:
		hour = hour + 24		
	hours = hour - current.tm_hour	
	
	if hours == 0 and target.tm_min < current.tm_min:
		hours = 24	
		
	return (hours * 3600) + ((target.tm_min - current.tm_min) * 60) - current.tm_sec

def main():	
	try:		
		if sys.argv[1] == 'in':
			secs = getsecsfrommins(sys.argv[2])
			
			if secs < 0:
				raise ValueError
				
			alreadyleaving()
			print "Leaving in " + sys.argv[2] + " minutes..."
			set(secs)
			
		elif sys.argv[1] == 'at':
			secs = getsecsuntil(sys.argv[2])
			alreadyleaving()
			print "Leaving at " + sys.argv[2] + "..."
			set(secs)
			
		elif sys.argv[1] == 'cancel':
			kill()
			
		else:
			raise IndexError
			
	except IndexError:
		print "Command syntax should be 'leave [in|at] time'"
		
	except ValueError:
		print "Values are incorrect:" 
		print "    'in' values are positive integers (minutes)" 
		print "    'at' values are of the form 'hours:mins'"

if __name__ == '__main__':
	main()