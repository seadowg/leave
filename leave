#!/usr/bin/env python
# encoding: utf-8
#
# Created by Callum Stott 2011

import sys
import os 
import time
import signal
import socket
import threading
import Growl

class Listener(threading.Thread):
	def run(self):
		hole = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		hole.bind(('', 1337))
		hole.listen(1)
		while True:
			stream, address = hole.accept()
			if stream.recv(100) == "kill":
				stream.close()
				hole.close()
				killthis()

class Timer:
	def __init__(self, time):
		self.time = time
		
	def run(self):
		time.sleep(self.time)

class Growler:
	def __init__(self):
		self.reggrowl()
		
	def notify(self):
		self.growl.notify( "Leaving time", "Time to leave!", "Go go go!", None, True, None)
			
	def reggrowl(self):
		self.growl = Growl.GrowlNotifier( "Leave", ["Leaving time"] )
		self.growl.register()
		
def daemonize():
	try:
		pid = os.fork()
	
	except OSError:
		pass
	
	if pid == 0:
		os.setsid()
	
		try:
			pid = os.fork()
	
		except OSError:
			pass
			
		if pid != 0:
			os._exit(0)
			
	else:
		os._exit(0)
		
def kill():
	kill = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	try:
		kill.connect(('localhost', 1337))
		kill.send("kill")
		kill.close()
	except socket.error:
		pass
			
def killthis():
	os._exit(0)

def alreadyleaving():
	search = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	try:
		search.connect(('localhost', 1337))
		print "You are alreading leaving!"
		sys.exit(0)
	except socket.error:
		pass


def startlistener():
	Listener().start()
			
def set(secs):
	daemonize()
	growl = Growler()
	timer = Timer(secs)
	startlistener()
	timer.run()
	growl.notify()
	
def getsecsfrommins(input):
	return int(input) * 60
		
def getsecsuntil(input):
	current = time.localtime()
	target = time.strptime(input, "%H:%M")
	hour = target.tm_hour

	if target.tm_hour < current.tm_hour:
		hour = hour + 24
		
	hours = hour - current.tm_hour
	
	if hours == 0 and target.tm_min < current.tm_min:
		hours = 24
		
	return (hours * 3600) + ((target.tm_min - current.tm_min) * 60) - current.tm_sec

def main():	
	try:		
		if sys.argv[1] == 'in':
			alreadyleaving()
			secs = getsecsfrommins(sys.argv[2])
			
			if secs < 0:
				raise ValueError
				
			print "Leaving in " + sys.argv[2] + " minutes..."
			set(secs)
			
		elif sys.argv[1] == 'at':
			alreadyleaving()
			secs = getsecsuntil(sys.argv[2])
			print "Leaving at " + sys.argv[2] + "..."
			set(secs)
			
		elif sys.argv[1] == 'cancel':
			kill()
			
		else:
			raise IndexError
			
	except IndexError:
		print "Command syntax should be 'leave [in|at] time'"
		
	except ValueError:
		print "Values are incorrect:" 
		print "    'in' values are positive integers (minutes)" 
		print "    'at' values are of the form 'hours:mins'"

if __name__ == '__main__':
	main()